<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />




<title></title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/cosmo.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<!DOCTYPE html>
<head>
<!-- Favicon for various operating systems -->
<link rel="apple-touch-icon" sizes="180x180" href="./favicon/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="./favicon/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="./favicon/favicon-16x16.png">
<!-- <link rel="manifest" href="./favicon/site.webmanifest"> -->
<link rel="mask-icon" href="./favicon/safari-pinned-tab.svg" color="#603cba">
<link rel="shortcut icon" href="./favicon/favicon.ico">
<meta name="msapplication-TileColor" content="#603cba">
<meta name="msapplication-config" content="./favicon/browserconfig.xml">
<meta name="theme-color" content="#382121">
</head>


<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; background-color: #f8f8f8; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
pre, code { background-color: #f8f8f8; }
code > span.kw { color: #204a87; font-weight: bold; } /* Keyword */
code > span.dt { color: #204a87; } /* DataType */
code > span.dv { color: #0000cf; } /* DecVal */
code > span.bn { color: #0000cf; } /* BaseN */
code > span.fl { color: #0000cf; } /* Float */
code > span.ch { color: #4e9a06; } /* Char */
code > span.st { color: #4e9a06; } /* String */
code > span.co { color: #8f5902; font-style: italic; } /* Comment */
code > span.ot { color: #8f5902; } /* Other */
code > span.al { color: #ef2929; } /* Alert */
code > span.fu { color: #000000; } /* Function */
code > span.er { color: #a40000; font-weight: bold; } /* Error */
code > span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #000000; } /* Constant */
code > span.sc { color: #000000; } /* SpecialChar */
code > span.vs { color: #4e9a06; } /* VerbatimString */
code > span.ss { color: #4e9a06; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #000000; } /* Variable */
code > span.cf { color: #204a87; font-weight: bold; } /* ControlFlow */
code > span.op { color: #ce5c00; font-weight: bold; } /* Operator */
code > span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */
code > span.ex { } /* Extension */
code > span.at { color: #c4a000; } /* Attribute */
code > span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */
code > span.an { color: #8f5902; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */
</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>


<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>

<link rel="stylesheet" href="styles.css" type="text/css" />

</head>

<body>

<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
  height: auto;
}
.tabbed-pane {
  padding-top: 12px;
}
button.code-folding-btn:focus {
  outline: none;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 51px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 56px;
  margin-top: -56px;
}

.section h2 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h3 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h4 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h5 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h6 {
  padding-top: 56px;
  margin-top: -56px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>


<div class="container-fluid main-container">

<!-- tabsets -->
<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});
</script>

<!-- code folding -->






<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">danStich</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="../../index.html">Home</a>
</li>
<li>
  <a href="../../teaching.html">Teaching</a>
</li>
<li>
  <a href="../../research.html">Research</a>
</li>
<li>
  <a href="../../cv.html">Curriculum vitae</a>
</li>
<li>
  <a href="../../courseWebsites.html">Course websites</a>
</li>
<li>
  <a href="../../contact.html">Contact</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div class="fluid-row" id="header">




</div>


<style>
pre code, pre, code {
  white-space: pre !important;
  overflow-x: scroll !important;
  word-break: keep-all !important;
  word-wrap: initial !important;
}

.column {
    float: left;
    padding: 15px;
}

.clearfix::after {
    content: "";
    clear: both;
    display: table;
}

.content {
    width: 75%;
}

</style>
<p><br></p>
<div id="generalized-linear-mixed-models" class="section level2">
<h2>Generalized linear mixed models</h2>
<p><br></p>
</div>
<div id="introducing-the-glmm" class="section level2">
<h2>Introducing the GLMM</h2>
<p><br></p>
<p>This week, we will continue our discussions about mixed effects models and extend the linear mixed model (LMM) to include error distributions other than the normal. This should feel pretty familiar to the transition that we made from the general linear model (ANCOVA) to the generalized linear model (GLM) a few weeks ago (I know, it feels like it was only yesterday).</p>
<p>For our first example this week, we will use the same data from last week that we used to demonstrate binomial logistic regression. This time, we will add in a random intercept term that will allow us to account for repeated observations within a year. This has two implications: 1) it accounts for the fact that the years in which we conducted this study are random samples from a larger, unobserved population, and 2) it accounts for the heterogeneity of variance that theoretically might occur as a result of taking multiple, and variable, numbers of measurements within a given year- thereby reducing the overall error of the model and our associated parameter estimates (in theory).</p>
<p><br></p>
</div>
<div id="data-explanation" class="section level2">
<h2>Data explanation</h2>
<p><br></p>
<p>Let’s start by reading in the data (copied and pasted from GLM lessons).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Let&#39;s read in the smolt data set that we used last time</span>
  choice =<span class="st"> </span><span class="kw">read.csv</span>(<span class="st">&#39;http://employees.oneonta.edu/stichds/data/StillwaterChoiceData.csv&#39;</span>)

<span class="co"># Look at the first few rows of data</span>
  <span class="kw">head</span>(choice)</code></pre></div>
<pre><code>##   path year hatchery length mass date flow
## 1    0 2010        1    176   57  118  345
## 2    0 2005        1    205  101  128 1093
## 3    0 2010        1    180   56  118  345
## 4    0 2010        1    193   74  118  345
## 5    0 2005        1    189   76  128 1093
## 6    0 2010        1    180   65  118  345</code></pre>
<p><br></p>
<p>These data are from a study that examined factors affecting path choice by wild and hatchery-reared endangered Atlantic salmon smolts during seaward migration in the Penobscot River, Maine. State, local, and federal fishery managers were interested in understanding what factors affected migratory routing through the lower river because there were different numbers of dams, with different estimated smolt mortality rates, on either side of a large island hydropower project in this system. If managers could understand factors influencing migratory route, they might be able to manipulate flows, stocking dates, and dam operation to improve survival of these endangered fish. Furthermore, the results of the study were used to predict the effects of dam removal, and hydropower re-allocation in the lower river on population-level consequences for these fish. These data were part of a larger analysis:</p>
<p>Stich, D. S., M. M. Bailey, and J. D. Zydlewski. 2014. Survival of Atlantic salmon (<em>Salmo salar</em>) smolts through a hydropower complex. Journal of Fish Biology 85:1074-1096.</p>
<p><br></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># The data consist of the following variables:</span>
<span class="co"># path:     The migratory route used by individual fish. The choices were</span>
<span class="co">#           main-stem of the river (0) or the Stillwater Branch (1) around the</span>
<span class="co">#           island.</span>
<span class="co"># year:     The year in which individual fish were tagged and relocated using</span>
<span class="co">#           acoustic telemetry.</span>
<span class="co"># hatchery: An indicator describing if fish were reared in the wild (0) or in</span>
<span class="co">#           the federal conservation hatchery (1)</span>
<span class="co"># length:   Fish length (in mm)</span>
<span class="co"># mass:     Fish mass (in grams)</span>
<span class="co"># date:     Ordinal date on which the fish entered the hydrocomplex determined</span>
<span class="co">#           from time-stamps on acoustic receivers</span>
<span class="co"># flow:     Discharge recorded at the USGS gauge in the headpond of the dam</span>
<span class="co">#           several kilometers upstream of the hydropower complex.</span></code></pre></div>
<p><br></p>
</div>
<div id="data-analysis" class="section level2">
<h2>Data analysis</h2>
<p>We are going to use the 1/0 binary data to estimate the effects of a number of covariates of interest on the probability that an individual fish used the Stillwater Branch for migration in each year of this study using logistic regression. In order to do this, we will use the ‘logit’ link function in both our REML and Bayesian approaches. This function can be defined as:</p>
<p><br></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">    logit =<span class="st"> </span><span class="cf">function</span>(x){
      <span class="kw">log</span>(x <span class="op">/</span><span class="st"> </span>(<span class="dv">1</span><span class="op">-</span>x))
    }
  <span class="co"># The inverse of the logit function is:</span>
    invlogit =<span class="st"> </span><span class="cf">function</span>(x){
      <span class="kw">exp</span>(x) <span class="op">/</span><span class="st"> </span>(<span class="dv">1</span> <span class="op">+</span><span class="st"> </span><span class="kw">exp</span>(x))
    }
  <span class="co"># Since we are not interested in the linear trend in the use of the Stillwater</span>
  <span class="co"># Branch through time, we need to convert year to factor. This is the same as</span>
  <span class="co"># if we wanted to use this as a fixed effect in the model.</span>
    choice<span class="op">$</span>year =<span class="st"> </span><span class="kw">as.factor</span>(choice<span class="op">$</span>year)</code></pre></div>
<p><br></p>
<div id="reml-estimation" class="section level3">
<h3>REML Estimation</h3>
<p><br></p>
<p>We will start by estimating the probability of using the Stillwater Branch using a GLMM in restricted maximum likelihood estimation (REML). For this example, we will define a set of candidate models representing different hypotheses. These are the actual models that were used for hypothesis testing in the citation given above.</p>
<p>Define a set of models based on <em>a priori</em> combinations of explanatory variables.</p>
<p><br></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Load the lme4 library</span>
  <span class="kw">library</span>(lme4)

<span class="co"># Scale the flow variable</span>
  choice<span class="op">$</span>flow2 =<span class="st"> </span><span class="kw">c</span>(<span class="kw">scale</span>(choice<span class="op">$</span>flow, <span class="dt">center=</span><span class="ot">TRUE</span>, <span class="dt">scale=</span><span class="ot">TRUE</span>))
  choice<span class="op">$</span>length2 =<span class="st"> </span><span class="kw">c</span>(<span class="kw">scale</span>(choice<span class="op">$</span>length, <span class="dt">center=</span><span class="ot">TRUE</span>, <span class="dt">scale=</span><span class="ot">TRUE</span>))
  
<span class="co"># First, make an empty list to hold the models</span>
  mods=<span class="kw">list</span>()
<span class="co"># Now, fill the list with several a priori models</span>
  mods[[<span class="dv">1</span>]]=<span class="kw">glmer</span>(path<span class="op">~</span>(<span class="dv">1</span><span class="op">|</span>year)<span class="op">+</span>hatchery<span class="op">+</span>length<span class="op">+</span>flow,<span class="dt">family=</span>binomial,
                  <span class="dt">data=</span>choice)
  mods[[<span class="dv">2</span>]]=<span class="kw">glmer</span>(path<span class="op">~</span>(<span class="dv">1</span><span class="op">|</span>year)<span class="op">+</span>flow2,<span class="dt">family=</span>binomial,<span class="dt">data=</span>choice)
  mods[[<span class="dv">3</span>]]=<span class="kw">glmer</span>(path<span class="op">~</span>(<span class="dv">1</span><span class="op">|</span>year)<span class="op">+</span>hatchery,<span class="dt">family=</span>binomial, <span class="dt">data=</span>choice)
  mods[[<span class="dv">4</span>]]=<span class="kw">glmer</span>(path<span class="op">~</span>(<span class="dv">1</span><span class="op">|</span>year)<span class="op">+</span>length,<span class="dt">family=</span>binomial, <span class="dt">data=</span>choice)
  mods[[<span class="dv">5</span>]]=<span class="kw">glmer</span>(path<span class="op">~</span>(<span class="dv">1</span><span class="op">|</span>year)<span class="op">+</span>length<span class="op">+</span>hatchery,<span class="dt">family=</span>binomial,<span class="dt">data=</span>choice)
  mods[[<span class="dv">6</span>]]=<span class="kw">glmer</span>(path<span class="op">~</span>(<span class="dv">1</span><span class="op">|</span>year)<span class="op">+</span>length<span class="op">+</span>flow2,<span class="dt">family=</span>binomial,<span class="dt">data=</span>choice)
  mods[[<span class="dv">7</span>]]=<span class="kw">glmer</span>(path<span class="op">~</span>(<span class="dv">1</span><span class="op">|</span>year)<span class="op">+</span>hatchery<span class="op">+</span>flow2,<span class="dt">family=</span>binomial,<span class="dt">data=</span>choice)</code></pre></div>
<p><br></p>
<p><br></p>
<p>Give the models some names using the formulas for each of the models. <strong>Remember</strong>: models are stored as list objects in R, and each of those list objects (models) has names. We can reference those names using the <code>$</code> notation:</p>
<p><br></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="st"> </span><span class="kw">length</span>(mods)){
    <span class="kw">names</span>(mods)[i] =<span class="st"> </span><span class="kw">as.character</span>(<span class="kw">summary</span>(mods[[i]])<span class="op">$</span>call<span class="op">$</span>formula)[<span class="dv">3</span>]
  }</code></pre></div>
<p><br></p>
<p>Now, we use the <code>AICcmodavg</code> package to make a model selection table like we did previously:</p>
<p><br></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Load the library</span>
  <span class="kw">library</span>(AICcmodavg)
<span class="co"># Do model selection and make a table</span>
  modtable =<span class="st"> </span><span class="kw">aictab</span>( <span class="dt">cand.set =</span> mods, <span class="dt">modnames =</span> <span class="kw">names</span>(mods) )</code></pre></div>
<p><br></p>
<p>Finally, we can use these models to make predictions about the relationships in our models the same way we have done previously with linear models and GLMs.</p>
<p><br></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Start by making a new sequence of values from which to make predictions</span>
  newFlow =<span class="st"> </span><span class="kw">seq</span>(<span class="kw">min</span>(choice<span class="op">$</span>flow2), <span class="kw">max</span>(choice<span class="op">$</span>flow2), <span class="dv">1</span>)

<span class="co"># Let&#39;s go ahead and use the best model to make some predictions, as we</span>
<span class="co"># can see that flow is the most important variable here</span>
  beta_<span class="dv">0</span> =<span class="st"> </span><span class="kw">summary</span>(mods[[<span class="dv">2</span>]])<span class="op">$</span>coefficients[<span class="dv">1</span>,<span class="dv">1</span>]
  beta_<span class="dv">1</span> =<span class="st"> </span><span class="kw">summary</span>(mods[[<span class="dv">2</span>]])<span class="op">$</span>coefficients[<span class="dv">2</span>,<span class="dv">1</span>]

<span class="co"># Now, we can make predictions from this model-averaged estimate</span>
  preds =<span class="st"> </span><span class="kw">invlogit</span>(beta_<span class="dv">0</span> <span class="op">+</span><span class="st"> </span>beta_<span class="dv">1</span><span class="op">*</span>newFlow)

<span class="co"># Make a *quick* plot for data vis</span>
  <span class="kw">plot</span>(newFlow, preds, <span class="dt">type=</span><span class="st">&#39;l&#39;</span>, <span class="dt">xlab=</span><span class="st">&#39;Flow (cms)&#39;</span>, <span class="dt">ylab=</span><span class="st">&#39;p(Stillwater | flow)&#39;</span>)</code></pre></div>
<p><img src="11_glmm_files/figure-html/unnamed-chunk-9-1.png" width="672" /></p>
<p><br></p>
</div>
<div id="bayesian-implementation" class="section level3">
<h3>Bayesian implementation</h3>
<p><br></p>
<p>The other approach we could take is to model this as a hierarchical process using JAGS. The philosophical reasons for using this approach are essentially the same as above, but estimation as a hierarchical model allows us to ‘share’ information about the response between years. So, it looks like we don’t really have enough information to estimate the effects of year and flow separately in a single Bayesian regression model (too few independent observations within years), but we can share information across years to improve annual estimates of the probability of using the Stillwater Brance while simultaneously estimating the effect of flow. In general, this should result in better estimates for the covariate of interest. For ANCOVA (a.k.a. general linear models) or GLM in Bayesian inference this is really the approach we should take whenever we can, because we are assuming that all of our variables are drawn from random distributions for cases like this. This ‘hierarchical’ approach is essentially the Bayesian analogue to the GLMM in maximum likelihood estimation, but it is a little easier to interpret in my opinion.</p>
<p>First, let’s just re-define our variables so everything is in one place. Also note that here we standardize the covariate for flow.</p>
<p><br></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  ngroups =<span class="st"> </span><span class="kw">length</span>(<span class="kw">unique</span>(choice<span class="op">$</span>year))
  N =<span class="st"> </span><span class="kw">nrow</span>(choice)
  year =<span class="st"> </span><span class="kw">as.numeric</span>(<span class="kw">as.factor</span>(choice<span class="op">$</span>year))
  flow =<span class="st"> </span><span class="kw">c</span>(<span class="kw">scale</span>(choice<span class="op">$</span>flow, <span class="dt">center=</span><span class="ot">TRUE</span>, <span class="dt">scale=</span><span class="ot">TRUE</span>))</code></pre></div>
<p><br></p>
<blockquote>
<p>Specify the model</p>
</blockquote>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">modelstring=<span class="st">&quot;</span>
<span class="st">      model{</span>

<span class="st">        # Priors</span>
<span class="st">          for(i in 1:ngroups){</span>
<span class="st">            alpha[i] ~ dnorm(mu.int, tau.int) # Random intercepts</span>
<span class="st">          }</span>

<span class="st">          mu.int ~ dnorm(0, 0.001)            # Mean hyperparameter for ran. intercepts</span>
<span class="st">          tau.int &lt;- 1/(sigma.int*sigma.int)  # Precision for random intercepts</span>
<span class="st">          sigma.int ~ dunif(0, 100)           # SD hyperparameter for ran. intercepts</span>

<span class="st">          beta ~ dnorm(0, 0.001)              # Common slope for beta</span>

<span class="st">        # Likelihood</span>
<span class="st">          for(i in 1:N){</span>
<span class="st">            y[i] ~ dbern(mu[i])</span>
<span class="st">            logit(mu[i]) &lt;- alpha[year[i]] + beta*flow[i]</span>
<span class="st">          }</span>
<span class="st">        }</span>
<span class="st">&quot;</span>
<span class="kw">writeLines</span>(modelstring, <span class="st">&quot;choiceModel.txt&quot;</span>)</code></pre></div>
<blockquote>
<p>Make the data</p>
</blockquote>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Package the data in a list for JAGS</span>
    jags.data &lt;-<span class="st"> </span><span class="kw">list</span>(
      <span class="dt">y =</span> choice<span class="op">$</span>path,
      <span class="dt">N =</span> N,
      <span class="dt">year =</span> year,
      <span class="dt">flow=</span>flow,
      <span class="dt">ngroups=</span>ngroups
    )</code></pre></div>
<blockquote>
<p>Define parameters for monitoring</p>
</blockquote>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Specify the parameters we want to monitor</span>
    parameters =<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;alpha&quot;</span>, <span class="st">&quot;beta&quot;</span>, <span class="st">&quot;mu.int&quot;</span>, <span class="st">&quot;sigma.int&quot;</span>)</code></pre></div>
<blockquote>
<p>Specify initial values</p>
</blockquote>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Make a function to declare some initial values.</span>
    inits =<span class="st"> </span><span class="cf">function</span>(){
      <span class="kw">list</span>(
        <span class="dt">alpha =</span> <span class="kw">rnorm</span>(ngroups, <span class="dv">0</span>, <span class="dv">2</span>),
        <span class="dt">beta =</span> <span class="kw">rnorm</span>(<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>),
        <span class="dt">mu.int =</span> <span class="kw">rnorm</span>(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>),
        <span class="dt">sigma.int =</span> <span class="kw">rlnorm</span>(<span class="dv">1</span>)
      )
    }</code></pre></div>
<blockquote>
<p>Define MCMC settings for Gibbs sampler</p>
</blockquote>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># MCMC settings</span>
  ni &lt;-<span class="st"> </span><span class="dv">3300</span>
  nt &lt;-<span class="st"> </span><span class="dv">3</span>
  nb &lt;-<span class="st"> </span><span class="dv">300</span>
  nc &lt;-<span class="st"> </span><span class="dv">3</span></code></pre></div>
<blockquote>
<p>Run the model</p>
</blockquote>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Load the R2jags library</span>
  <span class="kw">library</span>(R2jags)

<span class="co"># Call JAGS from R and run the model</span>
   choice_glmm &lt;-<span class="st"> </span><span class="kw">jags</span>(jags.data, inits, parameters,
     <span class="st">&quot;choiceModel.txt&quot;</span>, <span class="dt">n.chains =</span> nc, <span class="dt">n.thin =</span> nt, <span class="dt">n.iter =</span> ni,
     <span class="dt">n.burnin =</span> nb, <span class="dt">progress.bar =</span> <span class="st">&quot;none&quot;</span>)</code></pre></div>
<blockquote>
<p>Look at the results</p>
</blockquote>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Print the model</span>
  <span class="kw">print</span>(choice_glmm<span class="op">$</span>BUGSoutput<span class="op">$</span>summary[ , <span class="kw">c</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>,<span class="dv">7</span><span class="op">:</span><span class="dv">9</span>)])</code></pre></div>
<pre><code>##                  mean        sd         2.5%       97.5%     Rhat n.eff
## alpha[1]   -1.8110437 0.3255692  -2.41857196  -1.1552657 1.000966  3000
## alpha[2]   -2.2110558 0.2940034  -2.85418112  -1.6795959 1.006103   530
## alpha[3]   -1.6251195 0.2328094  -2.08806936  -1.1679660 1.001300  3000
## alpha[4]   -1.9077333 0.2614235  -2.39829346  -1.3711794 1.001922  1400
## alpha[5]   -2.3694961 0.3083907  -3.01098909  -1.8417460 1.001791  1600
## alpha[6]   -2.3097154 0.3091971  -2.97971113  -1.7750849 1.003269   760
## beta        0.5321079 0.1742034   0.21071044   0.8989847 1.002343  1100
## deviance  558.0153436 3.7459742 552.70208563 566.5445372 1.001002  3000
## mu.int     -2.0392871 0.2826074  -2.62676965  -1.5076433 1.002500  1000
## sigma.int   0.5354165 0.3458864   0.09500748   1.4260995 1.004270   560</code></pre>
<p><br></p>
<p>At a glance it is clear that this model has converged and we have effectively sampled the posterior distribution, even at a relatively low number of runs. If we wanted to, we could bump up our sampling intensity to get a few more estimates, but we won’t waste class time with that right now. Besides, we have pretty solid evidence that all of our parameters are well estimated.</p>
<p>If you have been paying close attention you are now noticing that our estimates for <code>alpha[1:6]</code> are NOT the same as the estimates in our GLM model in which p(Stillwater) was estimated separately for each year when we ran this as a fixed effects model (even if we do the logit transformation)!</p>
<p><br></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Invlogit</span>
  <span class="kw">invlogit</span>(
    <span class="kw">apply</span>(
      choice_glmm<span class="op">$</span>BUGSoutput<span class="op">$</span>sims.list<span class="op">$</span>alpha, <span class="dv">2</span>, mean
      )
    )     </code></pre></div>
<pre><code>## [1] 0.14051204 0.09876206 0.16450004 0.12923572 0.08552854 0.09032153</code></pre>
<p><br></p>
<p>Why is that?</p>
<p>It’s because these <strong>are not slopes</strong>. They are random intercepts for each year that govern the relationship between flow and path choice! You’ll also notice that if you invert the logit link function that not all of the estimates are uniformally larger or smaller. This is a phenomenon known as ‘shrinkage’. Because we are sharing data across multiple levels of a random factor, the tendency is for the sampler to pull the mean of each level nearer to the overall mean for the sampling ‘universe’ that is being considered here:</p>
<p><br></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">invlogit</span>(<span class="op">-</span><span class="fl">2.037</span>)</code></pre></div>
<pre><code>## [1] 0.1153726</code></pre>
<p><br></p>
<p>If you’ve <em>really</em> been paying attention for the last few weeks, you’ll recall that this estimate is actually <strong>identical</strong> to the estimate from the original GLMM analysis that we pulled these data from…</p>
<p><span class="math display">\[M_{ind} == BLOWN\]</span></p>
<p>This can obviously have important implications for inference. If what you are truly interested in here is the effect of year (and not flow) then the first approach may be warranted. We, however, are interested in both, so we proceed.</p>
<blockquote>
<p>Interpretting the results</p>
</blockquote>
<p>First, let’s grab our posterior estimates</p>
<p><br></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">posts =<span class="st"> </span>choice_glmm<span class="op">$</span>BUGSoutput<span class="op">$</span>sims.list</code></pre></div>
<p><br></p>
<p>Take a look at the names of the sims list and then the structure of this list so you know what the heck is going on here.</p>
<p><br></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">names</span>(posts) <span class="co"># We have 5 elements in our list</span></code></pre></div>
<pre><code>## [1] &quot;alpha&quot;     &quot;beta&quot;      &quot;deviance&quot;  &quot;mu.int&quot;    &quot;sigma.int&quot;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str</span>(posts)   <span class="co"># Notice that alpha is a matrix with six columns? Need that!</span></code></pre></div>
<pre><code>## List of 5
##  $ alpha    : num [1:3000, 1:6] -1.52 -1.42 -2.15 -1.66 -2.3 ...
##  $ beta     : num [1:3000, 1] 0.451 0.549 0.584 0.375 0.389 ...
##  $ deviance : num [1:3000, 1] 554 555 566 560 570 ...
##  $ mu.int   : num [1:3000, 1] -2.36 -2.03 -2 -2.26 -2.37 ...
##  $ sigma.int: num [1:3000, 1] 0.899 0.218 0.162 0.475 0.236 ...</code></pre>
<p><br></p>
<p>The first parameter we will look at here is beta to determine the overall effect of flow. The interpretation of this coefficient, because it is standardized, is the change in the probability of using the Stillwater Branch across all years given a 1 standard deviation change in flow.</p>
<p><br></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">beta.post =<span class="st"> </span>posts<span class="op">$</span>beta</code></pre></div>
<p><br></p>
<p>We can see that the 95% HDI for beta does not include zero, so we can conclude that there is a significant effect of flow on path choice, and that increased flow is associated with increased probability of using the Stillwater Branch.</p>
<p><br></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">hist</span>(beta.post, <span class="dt">main=</span><span class="st">&#39;&#39;</span>, <span class="dt">col=</span><span class="st">&#39;gray60&#39;</span>, <span class="dt">xlab=</span><span class="kw">expression</span>(beta), <span class="dt">breaks=</span><span class="dv">25</span>)
<span class="kw">abline</span>(<span class="dt">v=</span><span class="kw">mean</span>(beta.post), <span class="dt">col=</span><span class="st">&#39;blue&#39;</span>, <span class="dt">lty=</span><span class="dv">1</span>, <span class="dt">lwd=</span><span class="dv">2</span>)
<span class="kw">abline</span>(<span class="dt">v=</span><span class="kw">quantile</span>(beta.post, <span class="fl">0.025</span>), <span class="dt">col=</span><span class="st">&#39;red&#39;</span>, <span class="dt">lty=</span><span class="dv">2</span>, <span class="dt">lwd=</span><span class="dv">2</span>)
<span class="kw">abline</span>(<span class="dt">v=</span><span class="kw">quantile</span>(beta.post, <span class="fl">0.975</span>), <span class="dt">col=</span><span class="st">&#39;red&#39;</span>, <span class="dt">lty=</span><span class="dv">2</span>, <span class="dt">lwd=</span><span class="dv">2</span>)</code></pre></div>
<p><img src="11_glmm_files/figure-html/unnamed-chunk-23-1.png" width="672" /></p>
<p><br></p>
<p>Now, we can actually look at the change in flow with respect to a given year calculate the probability of using the Stillwater Branch given year and some new values for beta.</p>
<p><br></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  rflow =<span class="st"> </span><span class="kw">max</span>(flow)<span class="op">-</span><span class="kw">min</span>(flow)
  newFlow =<span class="st"> </span><span class="kw">seq</span>(<span class="kw">min</span>(flow), <span class="kw">max</span>(flow), <span class="dt">by =</span> rflow<span class="op">/</span><span class="kw">length</span>(beta.post))[<span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(beta.post)]
  p2005 =<span class="st"> </span><span class="kw">invlogit</span>(<span class="kw">mean</span>(posts<span class="op">$</span>alpha[,<span class="dv">1</span>]) <span class="op">+</span><span class="st"> </span><span class="kw">mean</span>(beta.post)<span class="op">*</span>newFlow)
  p2006 =<span class="st"> </span><span class="kw">invlogit</span>(<span class="kw">mean</span>(posts<span class="op">$</span>alpha[,<span class="dv">2</span>]) <span class="op">+</span><span class="st"> </span><span class="kw">mean</span>(beta.post)<span class="op">*</span>newFlow)
  p2009 =<span class="st"> </span><span class="kw">invlogit</span>(<span class="kw">mean</span>(posts<span class="op">$</span>alpha[,<span class="dv">3</span>]) <span class="op">+</span><span class="st"> </span><span class="kw">mean</span>(beta.post)<span class="op">*</span>newFlow)
  p2010 =<span class="st"> </span><span class="kw">invlogit</span>(<span class="kw">mean</span>(posts<span class="op">$</span>alpha[,<span class="dv">4</span>]) <span class="op">+</span><span class="st"> </span><span class="kw">mean</span>(beta.post)<span class="op">*</span>newFlow)
  p2011 =<span class="st"> </span><span class="kw">invlogit</span>(<span class="kw">mean</span>(posts<span class="op">$</span>alpha[,<span class="dv">5</span>]) <span class="op">+</span><span class="st"> </span><span class="kw">mean</span>(beta.post)<span class="op">*</span>newFlow)
  p2012 =<span class="st"> </span><span class="kw">invlogit</span>(<span class="kw">mean</span>(posts<span class="op">$</span>alpha[,<span class="dv">6</span>]) <span class="op">+</span><span class="st"> </span><span class="kw">mean</span>(beta.post)<span class="op">*</span>newFlow)

  pts =<span class="st"> </span><span class="kw">data.frame</span>(p2005, p2006, p2009, p2010, p2011, p2012)

  <span class="kw">plot</span>(newFlow, pts[,<span class="dv">1</span>], <span class="dt">type=</span><span class="st">&#39;l&#39;</span>)
  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="kw">ncol</span>(pts)){
    <span class="kw">lines</span>(newFlow, pts[ , i], <span class="dt">col=</span><span class="kw">terrain.colors</span>(<span class="dv">7</span>)[i], <span class="dt">lwd=</span><span class="dv">2</span>)
  }</code></pre></div>
<p><img src="11_glmm_files/figure-html/unnamed-chunk-24-1.png" width="672" /></p>
<p><br></p>
<p>Of course, if we were trying to show the uncertainty in each of our estimates we might do something more along these “lines”..hahaha!</p>
<p><br></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># 2005</span>
  mean2005 =<span class="st"> </span><span class="kw">invlogit</span>(<span class="kw">mean</span>(posts<span class="op">$</span>alpha[,<span class="dv">1</span>]) <span class="op">+</span><span class="st"> </span><span class="kw">mean</span>(beta.post)<span class="op">*</span>newFlow)
  <span class="kw">plot</span>(newFlow, mean2005, <span class="dt">type=</span><span class="st">&#39;l&#39;</span>, <span class="dt">col=</span><span class="st">&#39;white&#39;</span>, <span class="dt">ylim=</span><span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">1</span>))
  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="st"> </span><span class="kw">length</span>(beta.post)){
    nFlow =<span class="st"> </span><span class="kw">seq</span>(<span class="kw">min</span>(flow), <span class="kw">max</span>(flow), <span class="dt">by =</span> rflow<span class="op">/</span><span class="dv">10</span>)
    alpha =<span class="st"> </span><span class="kw">sample</span>(posts<span class="op">$</span>alpha[ , <span class="dv">1</span>], <span class="dv">1</span>)
    beta =<span class="st"> </span><span class="kw">sample</span>(beta.post, <span class="dv">1</span>)
    p =<span class="st"> </span><span class="kw">invlogit</span>(alpha <span class="op">+</span><span class="st"> </span>beta<span class="op">*</span>nFlow)
    <span class="kw">lines</span>(nFlow, p, <span class="dt">col=</span><span class="st">&#39;gray87&#39;</span>)
  }
  <span class="kw">box</span>()
  <span class="kw">lines</span>(newFlow, mean2005, <span class="dt">type=</span><span class="st">&#39;l&#39;</span>, <span class="dt">col=</span><span class="st">&#39;red&#39;</span>, <span class="dt">lwd=</span><span class="dv">2</span>)</code></pre></div>
<p><img src="11_glmm_files/figure-html/unnamed-chunk-25-1.png" width="672" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># 2006</span>
  mean2006 =<span class="st"> </span><span class="kw">invlogit</span>(<span class="kw">mean</span>(posts<span class="op">$</span>alpha[,<span class="dv">1</span>]) <span class="op">+</span><span class="st"> </span><span class="kw">mean</span>(beta.post)<span class="op">*</span>newFlow)
  <span class="kw">plot</span>(newFlow, mean2006, <span class="dt">type=</span><span class="st">&#39;l&#39;</span>, <span class="dt">col=</span><span class="st">&#39;white&#39;</span>, <span class="dt">ylim=</span><span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">1</span>))
  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="st"> </span><span class="kw">length</span>(beta.post)){
    nFlow =<span class="st"> </span><span class="kw">seq</span>(<span class="kw">min</span>(flow), <span class="kw">max</span>(flow), <span class="dt">by =</span> rflow<span class="op">/</span><span class="dv">100</span>)
    alpha =<span class="st"> </span><span class="kw">sample</span>(posts<span class="op">$</span>alpha[ , <span class="dv">2</span>], <span class="dv">1</span>)
    beta =<span class="st"> </span><span class="kw">sample</span>(beta.post, <span class="dv">1</span>)
    p =<span class="st"> </span><span class="kw">invlogit</span>(alpha <span class="op">+</span><span class="st"> </span>beta<span class="op">*</span>nFlow)
    <span class="kw">lines</span>(nFlow, p, <span class="dt">col=</span><span class="st">&#39;gray87&#39;</span>)
  }
  <span class="kw">box</span>()
  <span class="kw">lines</span>(newFlow, mean2006, <span class="dt">type=</span><span class="st">&#39;l&#39;</span>, <span class="dt">col=</span><span class="st">&#39;red&#39;</span>, <span class="dt">lwd=</span><span class="dv">2</span>)</code></pre></div>
<p><img src="11_glmm_files/figure-html/unnamed-chunk-25-2.png" width="672" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># 2009</span>
  mean2009 =<span class="st"> </span><span class="kw">invlogit</span>(<span class="kw">mean</span>(posts<span class="op">$</span>alpha[,<span class="dv">1</span>]) <span class="op">+</span><span class="st"> </span><span class="kw">mean</span>(beta.post)<span class="op">*</span>newFlow)
  <span class="kw">plot</span>(newFlow, mean2009, <span class="dt">type=</span><span class="st">&#39;l&#39;</span>, <span class="dt">col=</span><span class="st">&#39;white&#39;</span>, <span class="dt">ylim=</span><span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">1</span>))
  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="st"> </span><span class="kw">length</span>(beta.post)){
    nFlow =<span class="st"> </span><span class="kw">seq</span>(<span class="kw">min</span>(flow), <span class="kw">max</span>(flow), <span class="dt">by =</span> rflow<span class="op">/</span><span class="dv">100</span>)
    alpha =<span class="st"> </span><span class="kw">sample</span>(posts<span class="op">$</span>alpha[ , <span class="dv">3</span>], <span class="dv">1</span>)
    beta =<span class="st"> </span><span class="kw">sample</span>(beta.post, <span class="dv">1</span>)
    p =<span class="st"> </span><span class="kw">invlogit</span>(alpha <span class="op">+</span><span class="st"> </span>beta<span class="op">*</span>nFlow)
    <span class="kw">lines</span>(nFlow, p, <span class="dt">col=</span><span class="st">&#39;gray87&#39;</span>)
  }
  <span class="kw">box</span>()
  <span class="kw">lines</span>(newFlow, mean2009, <span class="dt">type=</span><span class="st">&#39;l&#39;</span>, <span class="dt">col=</span><span class="st">&#39;red&#39;</span>, <span class="dt">lwd=</span><span class="dv">2</span>)</code></pre></div>
<p><img src="11_glmm_files/figure-html/unnamed-chunk-25-3.png" width="672" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># 2010</span>
  mean2010 =<span class="st"> </span><span class="kw">invlogit</span>(<span class="kw">mean</span>(posts<span class="op">$</span>alpha[,<span class="dv">1</span>]) <span class="op">+</span><span class="st"> </span><span class="kw">mean</span>(beta.post)<span class="op">*</span>newFlow)
  <span class="kw">plot</span>(newFlow, mean2010, <span class="dt">type=</span><span class="st">&#39;l&#39;</span>, <span class="dt">col=</span><span class="st">&#39;white&#39;</span>, <span class="dt">ylim=</span><span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">1</span>))
  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="st"> </span><span class="kw">length</span>(beta.post)){
    nFlow =<span class="st"> </span><span class="kw">seq</span>(<span class="kw">min</span>(flow), <span class="kw">max</span>(flow), <span class="dt">by =</span> rflow<span class="op">/</span><span class="dv">100</span>)
    alpha =<span class="st"> </span><span class="kw">sample</span>(posts<span class="op">$</span>alpha[ , <span class="dv">4</span>], <span class="dv">1</span>)
    beta =<span class="st"> </span><span class="kw">sample</span>(beta.post, <span class="dv">1</span>)
    p =<span class="st"> </span><span class="kw">invlogit</span>(alpha <span class="op">+</span><span class="st"> </span>beta<span class="op">*</span>nFlow)
    <span class="kw">lines</span>(nFlow, p, <span class="dt">col=</span><span class="st">&#39;gray87&#39;</span>)
  }
  <span class="kw">box</span>()
  <span class="kw">lines</span>(newFlow, mean2010, <span class="dt">type=</span><span class="st">&#39;l&#39;</span>, <span class="dt">col=</span><span class="st">&#39;red&#39;</span>, <span class="dt">lwd=</span><span class="dv">2</span>)</code></pre></div>
<p><img src="11_glmm_files/figure-html/unnamed-chunk-25-4.png" width="672" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># 2011</span>
  mean2011 =<span class="st"> </span><span class="kw">invlogit</span>(<span class="kw">mean</span>(posts<span class="op">$</span>alpha[,<span class="dv">1</span>]) <span class="op">+</span><span class="st"> </span><span class="kw">mean</span>(beta.post)<span class="op">*</span>newFlow)
  <span class="kw">plot</span>(newFlow, mean2011, <span class="dt">type=</span><span class="st">&#39;l&#39;</span>, <span class="dt">col=</span><span class="st">&#39;white&#39;</span>, <span class="dt">ylim=</span><span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">1</span>))
  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="st"> </span><span class="kw">length</span>(beta.post)){
    nFlow =<span class="st"> </span><span class="kw">seq</span>(<span class="kw">min</span>(flow), <span class="kw">max</span>(flow), <span class="dt">by =</span> rflow<span class="op">/</span><span class="dv">100</span>)
    alpha =<span class="st"> </span><span class="kw">sample</span>(posts<span class="op">$</span>alpha[ , <span class="dv">5</span>], <span class="dv">1</span>)
    beta =<span class="st"> </span><span class="kw">sample</span>(beta.post, <span class="dv">1</span>)
    p =<span class="st"> </span><span class="kw">invlogit</span>(alpha <span class="op">+</span><span class="st"> </span>beta<span class="op">*</span>nFlow)
    <span class="kw">lines</span>(nFlow, p, <span class="dt">col=</span><span class="st">&#39;gray87&#39;</span>)
  }
  <span class="kw">box</span>()
  <span class="kw">lines</span>(newFlow, mean2011, <span class="dt">type=</span><span class="st">&#39;l&#39;</span>, <span class="dt">col=</span><span class="st">&#39;red&#39;</span>, <span class="dt">lwd=</span><span class="dv">2</span>)</code></pre></div>
<p><img src="11_glmm_files/figure-html/unnamed-chunk-25-5.png" width="672" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># 2012</span>
  mean2012 =<span class="st"> </span><span class="kw">invlogit</span>(<span class="kw">mean</span>(posts<span class="op">$</span>alpha[,<span class="dv">1</span>]) <span class="op">+</span><span class="st"> </span><span class="kw">mean</span>(beta.post)<span class="op">*</span>newFlow)
  <span class="kw">plot</span>(newFlow, mean2012, <span class="dt">type=</span><span class="st">&#39;l&#39;</span>, <span class="dt">col=</span><span class="st">&#39;white&#39;</span>, <span class="dt">ylim=</span><span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">1</span>))
  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="st"> </span><span class="kw">length</span>(beta.post)){
    nFlow =<span class="st"> </span><span class="kw">seq</span>(<span class="kw">min</span>(flow), <span class="kw">max</span>(flow), <span class="dt">by =</span> rflow<span class="op">/</span><span class="dv">100</span>)
    alpha =<span class="st"> </span><span class="kw">sample</span>(posts<span class="op">$</span>alpha[ , <span class="dv">6</span>], <span class="dv">1</span>)
    beta =<span class="st"> </span><span class="kw">sample</span>(beta.post, <span class="dv">1</span>)
    p =<span class="st"> </span><span class="kw">invlogit</span>(alpha <span class="op">+</span><span class="st"> </span>beta<span class="op">*</span>nFlow)
    <span class="kw">lines</span>(nFlow, p, <span class="dt">col=</span><span class="st">&#39;gray87&#39;</span>)
  }
  <span class="kw">box</span>()
  <span class="kw">lines</span>(newFlow, mean2012, <span class="dt">type=</span><span class="st">&#39;l&#39;</span>, <span class="dt">col=</span><span class="st">&#39;red&#39;</span>, <span class="dt">lwd=</span><span class="dv">2</span>)</code></pre></div>
<p><img src="11_glmm_files/figure-html/unnamed-chunk-25-6.png" width="672" /></p>
<p><br></p>
<p>Some of you may have noticed that the slope of lines does not change in this example. We could, of course implement this change in our model, and this essentially becomes the equivelant of adding an interaction term to our model.</p>
<p><br></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">modelstring=<span class="st">&quot;</span>
<span class="st">      model{</span>

<span class="st">        # Priors</span>
<span class="st">          for(i in 1:ngroups){</span>
<span class="st">            alpha[i] ~ dnorm(mu.int, tau.int) # Random intercepts</span>
<span class="st">            beta[i] ~ dnorm(mu.beta, tau.beta)  # Random slopes</span>
<span class="st">          }</span>

<span class="st">          mu.int ~ dnorm(0, 0.001)            # Mean hyperparameter for ran. intercepts</span>
<span class="st">          tau.int &lt;- 1/(sigma.int*sigma.int)  # Precision for random intercepts</span>
<span class="st">          sigma.int ~ dunif(0, 100)           # SD hyperparameter for ran. intercepts</span>

<span class="st">          mu.beta ~ dnorm(0, 0.001)            # Mean hyperparameter for ran. slopes</span>
<span class="st">          tau.beta &lt;- 1/(sigma.int*sigma.int)  # Precision for random slopes</span>
<span class="st">          sigma.beta ~ dunif(0, 100)           # SD hyperparameter for ran. slopes</span>

<span class="st">        # Likelihood</span>
<span class="st">          for(i in 1:N){</span>
<span class="st">            y[i] ~ dbern(mu[i])</span>
<span class="st">            logit(mu[i]) &lt;- alpha[year[i]] + beta[year[i]]*flow[i]</span>
<span class="st">          }</span>
<span class="st">        }</span>
<span class="st">        &quot;</span>
<span class="kw">writeLines</span>(modelstring, <span class="st">&quot;glmm.model2.txt&quot;</span>)
  
  <span class="co"># Package the data in a list for JAGS</span>
    jags.data &lt;-<span class="st"> </span><span class="kw">list</span>(
      <span class="dt">y =</span> choice<span class="op">$</span>path,
      <span class="dt">N =</span> N,
      <span class="dt">year =</span> year,
      <span class="dt">flow=</span>flow,
      <span class="dt">ngroups=</span>ngroups
    )

  <span class="co"># Specify the parameters we want to monitor</span>
    parameters =<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;alpha&quot;</span>, <span class="st">&quot;beta&quot;</span>, <span class="st">&quot;mu.int&quot;</span>, <span class="st">&quot;sigma.int&quot;</span>, <span class="st">&quot;mu.beta&quot;</span>,
                   <span class="st">&quot;sigma.beta&quot;</span>)

  <span class="co"># Make a function to declare some initial values.</span>
    inits =<span class="st"> </span><span class="cf">function</span>(){
      <span class="kw">list</span>(
        <span class="dt">alpha =</span> <span class="kw">rnorm</span>(ngroups, <span class="dv">0</span>, <span class="dv">2</span>),
        <span class="dt">beta =</span> <span class="kw">rnorm</span>(ngroups, <span class="dv">1</span>, <span class="dv">1</span>),
        <span class="dt">mu.int =</span> <span class="kw">rnorm</span>(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>),
        <span class="dt">mu.beta =</span> <span class="kw">rnorm</span>(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>),
        <span class="dt">sigma.int =</span> <span class="kw">rlnorm</span>(<span class="dv">1</span>),
        <span class="dt">sigma.beta =</span> <span class="kw">rlnorm</span>(<span class="dv">1</span>)
      )
    }

  <span class="co"># MCMC settings</span>
    ni &lt;-<span class="st"> </span><span class="dv">3300</span>
    nt &lt;-<span class="st"> </span><span class="dv">3</span>
    nb &lt;-<span class="st"> </span><span class="dv">300</span>
    nc &lt;-<span class="st"> </span><span class="dv">3</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  <span class="co"># Call JAGS from R and run the model</span>
     choice_glmm &lt;-<span class="st"> </span><span class="kw">jags</span>(jags.data, inits, parameters,
       <span class="st">&quot;glmm.model2.txt&quot;</span>, <span class="dt">n.chains =</span> nc, <span class="dt">n.thin =</span> nt, <span class="dt">n.iter =</span> ni,
       <span class="dt">n.burnin =</span> nb, <span class="dt">progress.bar =</span> <span class="st">&quot;none&quot;</span>)

  <span class="co"># Print the model</span>
    <span class="kw">print</span>(choice_glmm, <span class="dt">digits=</span><span class="dv">3</span>)</code></pre></div>
<p><br></p>
<p>Notice that this one takes a little longer to run, but now we can essentially make the same predictions that we did before and the rest of our estimated parameters are essentially identical to the values we got previously.</p>
<p>Let’s have a quick look at the output</p>
<p><br></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">    posts =<span class="st"> </span>choice_glmm<span class="op">$</span>BUGSoutput<span class="op">$</span>sims.list
    <span class="kw">names</span>(posts) <span class="co"># We have 7 elements in our list now</span></code></pre></div>
<pre><code>## [1] &quot;alpha&quot;      &quot;beta&quot;       &quot;deviance&quot;   &quot;mu.beta&quot;    &quot;mu.int&quot;    
## [6] &quot;sigma.beta&quot; &quot;sigma.int&quot;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">    <span class="kw">str</span>(posts)   <span class="co"># Notice that alpha AND betas are matrices now?</span></code></pre></div>
<pre><code>## List of 7
##  $ alpha     : num [1:3000, 1:6] -0.62 -2.22 -2 -2.38 -1.68 ...
##  $ beta      : num [1:3000, 1:6] 0.267 0.624 0.356 0.602 0.537 ...
##  $ deviance  : num [1:3000, 1] 558 569 565 557 556 ...
##  $ mu.beta   : num [1:3000, 1] 1.305 0.682 0.437 0.718 0.663 ...
##  $ mu.int    : num [1:3000, 1] -2.41 -2.68 -1.99 -2.03 -1.71 ...
##  $ sigma.beta: num [1:3000, 1] 48.12 86.17 9.82 35.75 58.42 ...
##  $ sigma.int : num [1:3000, 1] 1.171 0.42 0.134 0.221 0.276 ...</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">    <span class="co"># Calculate the probability of using the Stillwater Branch given year and</span>
    <span class="co"># some new values for beta</span>
      rflow =<span class="st"> </span><span class="kw">max</span>(flow)<span class="op">-</span><span class="kw">min</span>(flow)
      newFlow =<span class="st"> </span><span class="kw">seq</span>(<span class="kw">min</span>(flow), <span class="kw">max</span>(flow), <span class="dt">by =</span> rflow<span class="op">/</span><span class="kw">length</span>(beta.post))[<span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(beta.post)]
      p2005 =<span class="st"> </span><span class="kw">invlogit</span>(<span class="kw">mean</span>(posts<span class="op">$</span>alpha[,<span class="dv">1</span>]) <span class="op">+</span><span class="st"> </span><span class="kw">mean</span>(posts<span class="op">$</span>beta[,<span class="dv">1</span>])<span class="op">*</span>newFlow)
      p2006 =<span class="st"> </span><span class="kw">invlogit</span>(<span class="kw">mean</span>(posts<span class="op">$</span>alpha[,<span class="dv">2</span>]) <span class="op">+</span><span class="st"> </span><span class="kw">mean</span>(posts<span class="op">$</span>beta[,<span class="dv">1</span>])<span class="op">*</span>newFlow)
      p2009 =<span class="st"> </span><span class="kw">invlogit</span>(<span class="kw">mean</span>(posts<span class="op">$</span>alpha[,<span class="dv">3</span>]) <span class="op">+</span><span class="st"> </span><span class="kw">mean</span>(posts<span class="op">$</span>beta[,<span class="dv">1</span>])<span class="op">*</span>newFlow)
      p2010 =<span class="st"> </span><span class="kw">invlogit</span>(<span class="kw">mean</span>(posts<span class="op">$</span>alpha[,<span class="dv">4</span>]) <span class="op">+</span><span class="st"> </span><span class="kw">mean</span>(posts<span class="op">$</span>beta[,<span class="dv">1</span>])<span class="op">*</span>newFlow)
      p2011 =<span class="st"> </span><span class="kw">invlogit</span>(<span class="kw">mean</span>(posts<span class="op">$</span>alpha[,<span class="dv">5</span>]) <span class="op">+</span><span class="st"> </span><span class="kw">mean</span>(posts<span class="op">$</span>beta[,<span class="dv">1</span>])<span class="op">*</span>newFlow)
      p2012 =<span class="st"> </span><span class="kw">invlogit</span>(<span class="kw">mean</span>(posts<span class="op">$</span>alpha[,<span class="dv">6</span>]) <span class="op">+</span><span class="st"> </span><span class="kw">mean</span>(posts<span class="op">$</span>beta[,<span class="dv">1</span>])<span class="op">*</span>newFlow)

      pts =<span class="st"> </span><span class="kw">data.frame</span>(p2005, p2006, p2009, p2010, p2011, p2012)

      <span class="kw">plot</span>(newFlow, pts[,<span class="dv">1</span>], <span class="dt">type=</span><span class="st">&#39;l&#39;</span>)
      <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="kw">ncol</span>(pts)){
        <span class="kw">lines</span>(newFlow, pts[ , i], <span class="dt">col=</span><span class="kw">terrain.colors</span>(<span class="dv">7</span>)[i], <span class="dt">lwd=</span><span class="dv">2</span>)
      }</code></pre></div>
<p><img src="11_glmm_files/figure-html/unnamed-chunk-28-1.png" width="672" /></p>
<p><br></p>
<p>So, not much evidence for an interaction in this case, which, given the biology of this species and the potential mechanisms by which flow might influence path choice, is exactly what we would expect to see!</p>
<p><br></p>
</div>
</div>

<!DOCTYPE html>

<br>

<hr>

<p style="color:gray">This work is licensed under a <a href="https://creativecommons.org/licenses/by/4.0/legalcode">Creative Commons Attribution 4.0 International License.</a></p>



</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
