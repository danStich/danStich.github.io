<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />




<title></title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/cosmo.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<!DOCTYPE html>
<head>
<!-- Favicon for various operating systems -->
<link rel="apple-touch-icon" sizes="180x180" href="./favicon/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="./favicon/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="./favicon/favicon-16x16.png">
<!-- <link rel="manifest" href="./favicon/site.webmanifest"> -->
<link rel="mask-icon" href="./favicon/safari-pinned-tab.svg" color="#603cba">
<link rel="shortcut icon" href="./favicon/favicon.ico">
<meta name="msapplication-TileColor" content="#603cba">
<meta name="msapplication-config" content="./favicon/browserconfig.xml">
<meta name="theme-color" content="#382121">
</head>


<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; background-color: #f8f8f8; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
pre, code { background-color: #f8f8f8; }
code > span.kw { color: #204a87; font-weight: bold; } /* Keyword */
code > span.dt { color: #204a87; } /* DataType */
code > span.dv { color: #0000cf; } /* DecVal */
code > span.bn { color: #0000cf; } /* BaseN */
code > span.fl { color: #0000cf; } /* Float */
code > span.ch { color: #4e9a06; } /* Char */
code > span.st { color: #4e9a06; } /* String */
code > span.co { color: #8f5902; font-style: italic; } /* Comment */
code > span.ot { color: #8f5902; } /* Other */
code > span.al { color: #ef2929; } /* Alert */
code > span.fu { color: #000000; } /* Function */
code > span.er { color: #a40000; font-weight: bold; } /* Error */
code > span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #000000; } /* Constant */
code > span.sc { color: #000000; } /* SpecialChar */
code > span.vs { color: #4e9a06; } /* VerbatimString */
code > span.ss { color: #4e9a06; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #000000; } /* Variable */
code > span.cf { color: #204a87; font-weight: bold; } /* ControlFlow */
code > span.op { color: #ce5c00; font-weight: bold; } /* Operator */
code > span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */
code > span.ex { } /* Extension */
code > span.at { color: #c4a000; } /* Attribute */
code > span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */
code > span.an { color: #8f5902; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */
</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>


<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>

<link rel="stylesheet" href="styles.css" type="text/css" />

</head>

<body>

<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
  height: auto;
}
.tabbed-pane {
  padding-top: 12px;
}
button.code-folding-btn:focus {
  outline: none;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 51px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 56px;
  margin-top: -56px;
}

.section h2 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h3 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h4 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h5 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h6 {
  padding-top: 56px;
  margin-top: -56px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>


<div class="container-fluid main-container">

<!-- tabsets -->
<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});
</script>

<!-- code folding -->






<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">danStich</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="../../index.html">Home</a>
</li>
<li>
  <a href="../../teaching.html">Teaching</a>
</li>
<li>
  <a href="../../research.html">Research</a>
</li>
<li>
  <a href="../../cv.html">Curriculum vitae</a>
</li>
<li>
  <a href="../../courseWebsites.html">Course websites</a>
</li>
<li>
  <a href="../../contact.html">Contact</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div class="fluid-row" id="header">




</div>


<style>
pre code, pre, code {
  white-space: pre !important;
  overflow-x: scroll !important;
  word-break: keep-all !important;
  word-wrap: initial !important;
}

.column {
    float: left;
    padding: 15px;
}

.clearfix::after {
    content: "";
    clear: both;
    display: table;
}

.content {
    width: 75%;
}

</style>
<p><br></p>
<div id="linear-mixed-models-lmm" class="section level1">
<h1>Linear mixed models (LMM)</h1>
<p><br></p>
<div id="introduction" class="section level2">
<h2>Introduction</h2>
<p><br></p>
<p>This week we will talk about extending linear models and generalized linear models to include “random effects” in the model, thus resulting in the “generalized linear mixed model” or GLMM. The GLMM is actually the most generalized formulation of our linear models that we have been discussing now for the past several weeks. All linear models (ANOVA, regression, t-tests, etc.) are simply special cases of the GLMM. As such, we can think of the GLMM as the framework within which we have been working for weeks now! For this week, we will start with examples of the linear mixed model.</p>
<p><br></p>
</div>
<div id="assumptions-of-linear-models" class="section level2">
<h2>Assumptions of linear models</h2>
<p><br></p>
<p>OMG, why is this guy always talking about assumptions of linear models no matter what we do?!</p>
<p>Just as we discussed last week, linear models are just a special case of the GLMM. That is, the linear model assumes a certain error distribution (the normal) that helps things work smoothly and correctly. During the last two weeks, we discussed how we can use link functions to relax the assumption of linear models with respect to normality of residuals and homogeneity of variances, as well as assumptions about the linearity of relationships between explanatory variables and responses of interest by using data transformation. This week, we continue to relax the underlying assumptions of linear models to unleash the true power of estimation in mixed effects models. This is essentially as far as the basic framework for linear modeling goes (with the exception of multivariate techniques), and all other cases (e.g. spatial and temporal autocorrelation regressions) are simply specialized instances of these models.</p>
<p>Let’s take another look at the assumptions of linear models. Here, we will repeat the mantra from the past few weeks. Here are the three assumptions that we explicitly use when we use linear models, just in case you’ve forgotten them:</p>
<p><br></p>

<ol style="list-style-type: decimal">
<li>Residuals are normally distributed with a mean of zero</li>
</ol>

<ol start="2" style="list-style-type: decimal">
<li><p>Independence of observations (residuals)</p>
<ul>
<li>Colinearity</li>
<li>Auto correlation of errors (e.g., spatial &amp; temporal)</li>
</ul></li>
</ol>

<ol start="3" style="list-style-type: decimal">
<li>Homogeneity</li>
</ol>

<ol start="4" style="list-style-type: decimal">
<li>Linear relationship between X and Y</li>
</ol>
<p><br></p>
<div id="assumption-1-normality-of-residuals" class="section level3">
<h3>Assumption 1: Normality of residuals</h3>
<p><br></p>
<p>We’ve seen these before, but let’s recap. For assumption 1, we are assuming a couple of implicit things: 1. The variable is <em>continuous</em> (and it must be if it’s error structure is normal), and 2. The error in our model is normally distributed. In reality, this is probably the least important assumption of linear models, and really only matters if we are trying to make predictions from the models that we make. Of course, we are often concerned with making predictions from the models that we make, so we can see why this might be important. However, more often we are in extreme violation of this assumption in some combination with assumption 4 above to such a degree that it actually does matter. For example, a response variable that is binomial (1 or zero) or multinomial in nature cannot possibly have normally distributed errors with respect to x unless there is absolutely no relationship between X and Y, right? So, if we wanted to predict the probability of patients dying from some medical treatment, or the presence/absence of species across a landscape then we can’t use linear models. This is where the link functions that we have been discussing really come into play. The purpose of the link function is to place our decidedly non-normal error structures into an asymptotically normal probability space. The other key characteristic of the link function is that it must be invertible, that way we can get back to the parameter scale that we want to use for making predictions and visualizing the results of our models.</p>
<p><br></p>
</div>
<div id="assumption-2-independence-of-observations" class="section level3">
<h3>Assumption 2: Independence of observations</h3>
<p><br></p>
<p>This time we’ve broken assumption 2 in two components: Colinearity and autocorrelation of errors. Remember that the manifestation of these problems is in the precision of our coefficient estimates, and have the potential to change the Type-I/II error rates in our models, causing us to draw false conclusions about which variables are important. As we discussed earlier in the course we expect to see some colinearity between observations, and we can deal with balancing this in our modeling through the use of model selection techniques to reduce Type-I and Type-II error. The past couple of weeks, we examined tools that help us determine whether or not colinearity is actually causing problems in our models that go beyond minor nuisances. As for the second part, autocorrelation, we looked at formulations of the GLM that used ‘generalized least squares’ to include auto-regressive correlation matrices in our analysis that will allowed us to relax this assumption of linear models and improve the precision of our parameter estimates. This week, we will further extend this to include random effects to account for non-independence in the observations, and correlation in the residual errors of explanatory variables that could otherwise cause issues with accuracy and precision of our estimates. We will continue to use model selection as a method for determining tradeoffs between information gain and parameter redundancy that results from colinearity between explanatory variables, as well as for hypothesis testing.</p>
<p><br></p>
</div>
<div id="assumption-3-homogeneity-of-variances" class="section level3">
<h3>Assumption 3: Homogeneity of variances</h3>
<p><br></p>
<p>In past weeks, we looked at ways to reduce this issue by introducing blocking (categorical) variables to our models. Last week, we noted that this could be further mitigated through the use of weighted least squares and MLE within the GLM framework, which can be applied to a wide range of regression methods from linear models to GLMs and GLMMs. This week we will examine how we can use various formulations of the GLMM to account for heteroscedasticity in residual errors directly by including the appropriate error terms in our models. This essentially means that we can start to account for things like repeated measures, nested effects, and various other violations through the use of one tool- nifty!!</p>
<p><br></p>
</div>
<div id="assumption-4-linearity-and-additivity" class="section level3">
<h3>Assumption 4: Linearity and additivity</h3>
<p><br></p>
<p>We’ve already looked at a couple of ways to deal with violations of these assumptions such as data transformation and/or polynomial formulations of the linear model. We will continue to apply these concepts this week as we begin to investigate the GLMM as robust framework for analysis.</p>
<p><br></p>
</div>
</div>
<div id="introducing-the-glmm" class="section level2">
<h2>Introducing the GLMM</h2>
<p><br></p>
<p>The first thing you should understand about GLMMs is that they are useful for analyzing data from a large number of statistical probability distributions (basically, you can use them for any underlying error structure). But, when we use specific error structures, or make certain assumptions about the manner in which the heterogeneity of variances is structured with respect to specific factors, this model is often given specific names. For example, repeated measures ANOVA (or ANCOVA), nested ANOVA(or ANCOVA), factorial ANOVA (or ANCOVA), linear mixed models, linear mixed effects models, and generalized linear mixed effects models are all just different formulations of the GLMM with different names. It sounds confusing, but just remember this: any linear model with combinations of fixed and random effects is, at it’s core, just another GLMM! If you can convince yourself of this, you will improve your ability to understand a wide range of experimental designs and accompanying statistical models by understanding this one model type.</p>
<p><br></p>
<p>The second thing you should understand to “get” GLMMs is what exactly is meant by a “random effect”. So far in this course we have only dealt with “fixed” group effects. The fixed effect is a categorical variable that is used to explain some variation in our response of interest. When we use a fixed effect in a statistical model, we are making the assumption that the categories for this effect are “fixed”. In other words, we have assigned the the levels, or categories, based on some <em>a priori</em> knowledge that the levels themselves represent all possible groups that can be used to describe the data. Because of this definition, fixed effects are usually 1) things that we manipulate directly (like dosage or some other treatment), or 2) relatively simple grouping variables such as sex. By contrast, a “random effect” is an effect that we do not generally set ahead of time or manipulate, but rather one which is considered to be a sample from a population of potential categories that we cannot census or (often) control. Please note that there is not a single, widely accepted definition for either of these things in applied statistics and the definition can be context-specific. Don’t take it from me, though, ask Andrew Gelman, globally recognized as one of the world’s leading experts on applied statistics, including the development of many modern approaches <a href="http://andrewgelman.com/2005/01/25/why_i_dont_use/">here</a>.</p>
<p><br></p>
</div>
<div id="linear-mixed-models" class="section level2">
<h2>Linear mixed models</h2>
<p><br></p>
<p>We will start our explorations into GLMM by looking at the somewhat familiar case of normal data. As with the relationship between ANOVA and GLM, we can say that the linear mixed model (LMM) is just a special case of the GLMM (hence the name).</p>
<p>So, what is a mixed model? This is a model that assumes some parameter of interest is drawn from a random sample from a distribution of possible samples. We usually use these when we are dealing with repeated samples for some group or individual, or if we wish to account for some latent variable beyond our control (e.g. lake). Essentially, the use of random effects allows us to remove extraneous noise (variance) from the study system by accounting for it directly. This can improve both the accuracy and the precision of estimates to make hypothesis testing more robust. It also allows us to generalize our conclusions to a broader scope (e.g. any lake instead of lakes X, Y, and Z). Finally, the approach allows for a great deal of flexibility in assumptions we make about the effects and associated errors in our model. We might assume within our model that effects are randomized by assigning random intercepts, random slopes and intercepts that are independent, or random slopes or intercepts that are correlated across our random variable. There are even rare cases when we might wish to examine random slopes with shared intercepts. Generally speaking, we want our random variable to contain a relatively large number of potential levels (usually &gt; 5) as this tends to result in more accurate, and more precise parameter estimates.</p>
<p>As with so many things, these tools are often best investigated through the use of a worked example. For this section, we will use the data presented in Chapter 12 of Kery (2010), and we’ll walk through both frequentist and Bayesian implementations of the LMM.</p>
<p><br></p>
</div>
<div id="worked-example" class="section level2">
<h2>Worked example</h2>
<p><br></p>
<p>We will start by generating the data used in the book chapter. These data are for the viper asps from Chapter 9, with a new twist. Here, we simulate length and mass data for 10 vipers from each of 56 different populations. I will not cover the following in detail here, but I encourage you to delve into it as you work through your text book.</p>
<p><br></p>
<div id="data-generation" class="section level3">
<h3>Data generation</h3>
<p><br></p>
<p>Here is the code, shamelessly copy-and-pasted from Chapter 12</p>
<p><br></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">n.groups &lt;-<span class="st"> </span><span class="dv">56</span>              <span class="co"># Number of populations</span>
n.sample &lt;-<span class="st"> </span><span class="dv">10</span>              <span class="co"># Number of vipers in each pop</span>
n &lt;-<span class="st"> </span>n.groups <span class="op">*</span><span class="st"> </span>n.sample        <span class="co"># Total number of data points</span>
pop &lt;-<span class="st"> </span><span class="kw">gl</span>(<span class="dt">n =</span> n.groups, <span class="dt">k =</span> n.sample)   <span class="co"># Indicator for population</span>

<span class="co"># Body length (cm)</span>
original.length &lt;-<span class="st"> </span><span class="kw">runif</span>(n, <span class="dv">45</span>, <span class="dv">70</span>) 
mn &lt;-<span class="st"> </span><span class="kw">mean</span>(original.length)
sd &lt;-<span class="st"> </span><span class="kw">sd</span>(original.length)
<span class="kw">cat</span>(<span class="st">&quot;Mean and sd used to normalise.original length:&quot;</span>, mn, sd, <span class="st">&quot;</span><span class="ch">\n\n</span><span class="st">&quot;</span>)</code></pre></div>
<pre><code>## Mean and sd used to normalise.original length: 57.22358 7.289042</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">length &lt;-<span class="st"> </span>(original.length <span class="op">-</span><span class="st"> </span>mn) <span class="op">/</span><span class="st"> </span>sd
<span class="kw">hist</span>(length, <span class="dt">col =</span> <span class="st">&quot;grey&quot;</span>)</code></pre></div>
<p><img src="10_lmm_files/figure-html/unnamed-chunk-2-1.png" width="672" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">Xmat &lt;-<span class="st"> </span><span class="kw">model.matrix</span>(<span class="op">~</span>pop<span class="op">*</span>length<span class="op">-</span><span class="dv">1</span><span class="op">-</span>length)

intercept.mean &lt;-<span class="st"> </span><span class="dv">230</span>           <span class="co"># mu_alpha</span>
intercept.sd &lt;-<span class="st"> </span><span class="dv">20</span>            <span class="co"># sigma_alpha</span>
slope.mean &lt;-<span class="st"> </span><span class="dv">60</span>                <span class="co"># mu_beta</span>
slope.sd &lt;-<span class="st"> </span><span class="dv">30</span>                  <span class="co"># sigma_beta</span>

intercept.effects&lt;-<span class="kw">rnorm</span>(<span class="dt">n =</span> n.groups, <span class="dt">mean =</span> intercept.mean, <span class="dt">sd =</span> intercept.sd)
slope.effects &lt;-<span class="st"> </span><span class="kw">rnorm</span>(<span class="dt">n =</span> n.groups, <span class="dt">mean =</span> slope.mean, <span class="dt">sd =</span> slope.sd)
all.effects &lt;-<span class="st"> </span><span class="kw">c</span>(intercept.effects, slope.effects) <span class="co"># Put them all together</span>

lin.pred &lt;-<span class="st"> </span>Xmat[,] <span class="op">%*%</span><span class="st"> </span>all.effects     <span class="co"># Value of lin.predictor</span>
eps &lt;-<span class="st"> </span><span class="kw">rnorm</span>(<span class="dt">n =</span> n, <span class="dt">mean =</span> <span class="dv">0</span>, <span class="dt">sd =</span> <span class="dv">30</span>)  <span class="co"># residuals </span>
mass &lt;-<span class="st"> </span>lin.pred <span class="op">+</span><span class="st"> </span>eps                      <span class="co"># response = lin.pred + residual</span>

<span class="kw">hist</span>(mass, <span class="dt">col =</span> <span class="st">&quot;grey&quot;</span>)                    <span class="co"># Inspect what we&#39;ve created</span>

<span class="kw">library</span>(lattice)</code></pre></div>
<p><img src="10_lmm_files/figure-html/unnamed-chunk-2-2.png" width="672" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">xyplot</span>(mass <span class="op">~</span><span class="st"> </span>length <span class="op">|</span><span class="st"> </span>pop)</code></pre></div>
<p><img src="10_lmm_files/figure-html/unnamed-chunk-2-3.png" width="672" /></p>
<p><br></p>
<p>So, as you can see we have successfully created 56 populations of critters, each of which has some pre-defined relationship between length and mass based on 10 samples from the population. Wow. What a mess. Next, we will take a look at a few different ways to analyze these data using maximum likelihood estimation and Bayesian inference. Ultimately, what we want to do here is estimate the relationship between length and mass while accounting for inherent (well, simulated) variability between populations.</p>
<p><br></p>
</div>
<div id="random-intercepts-model" class="section level3">
<h3>Random-intercepts model</h3>
<p><br></p>
<p>First, we will analyze the data assuming that the intercepts for our linear model can vary between populations, but the relationship between length and mass is the same across all populations. This is a very common approach in many ecological and biological applications, as it often is the case that we are just trying to account for sampling design when we do this kind of analysis.</p>
<p><br></p>
<div id="reml-estimation" class="section level4">
<h4>REML estimation</h4>
<p><br></p>
<p>This is really straightforward to do in R. First, we will load the <code>lme4</code> package that we will use for all LMM and GLMM implementation in this class. Then, we fit the model and print the output.</p>
<p><br></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Load the lme4 library</span>
<span class="kw">library</span>(lme4)

<span class="co"># Fit the model</span>
lme.fit1 &lt;-<span class="st"> </span><span class="kw">lmer</span>(mass <span class="op">~</span><span class="st"> </span>length <span class="op">+</span><span class="st"> </span>(<span class="dv">1</span> <span class="op">|</span><span class="st"> </span>pop), <span class="dt">REML =</span> <span class="ot">TRUE</span>)

<span class="co"># Have a look</span>
<span class="kw">summary</span>(lme.fit1)</code></pre></div>
<pre><code>## Linear mixed model fit by REML [&#39;lmerMod&#39;]
## Formula: mass ~ length + (1 | pop)
## 
## REML criterion at convergence: 5814.8
## 
## Scaled residuals: 
##     Min      1Q  Median      3Q     Max 
## -3.3276 -0.6077  0.0391  0.5631  3.6570 
## 
## Random effects:
##  Groups   Name        Variance Std.Dev.
##  pop      (Intercept)  480     21.91   
##  Residual             1681     41.00   
## Number of obs: 560, groups:  pop, 56
## 
## Fixed effects:
##             Estimate Std. Error t value
## (Intercept)  225.578      3.402   66.31
## length        65.366      1.815   36.02
## 
## Correlation of Fixed Effects:
##        (Intr)
## length 0.000</code></pre>
<p><br></p>
<p>As we look throught the output, the first thing that you’ll probably notice is that we don’t have a p-value, which is probably already driving some people nuts. This is a bit of a philosophical sticking point, which is why it is not included in the default print method for the summary of these objects. Here, we can do statistical inference based on the overlap with our coefficient estimates with zero. What does this look like?</p>
<p>Let’s say we want to see if our explanatory variable is significantly related to the response of interest, but we don’t have a p-value. If we still wanted to test significance with respect to some variable (at <span class="math inline">\(\alpha\)</span> = 0.05), we could estimate the 95% CI for the regression coefficient and determine whether or not the 95% CI includes zero, like so:</p>
<p><br></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Get the coefficients from the model</span>
  coefs =<span class="st"> </span><span class="kw">summary</span>(lme.fit1)<span class="op">$</span>coefficients

<span class="co"># Compute 95% CI on regression coefficient for length above</span>
<span class="co"># We add or subtract 1.96 times the standard error for the</span>
<span class="co"># coefficient because 95% of the data fall within +/- 1.96</span>
<span class="co"># standard deviations of the mean</span>
  lengthCI =<span class="st"> </span><span class="kw">c</span>(coefs[<span class="dv">2</span>,<span class="dv">1</span>]<span class="op">-</span>(<span class="fl">1.96</span><span class="op">*</span>coefs[<span class="dv">2</span>,<span class="dv">2</span>]),
               coefs[<span class="dv">2</span>,<span class="dv">1</span>]<span class="op">+</span>(<span class="fl">1.96</span><span class="op">*</span>coefs[<span class="dv">2</span>,<span class="dv">2</span>])
               )

<span class="co"># Print the CI to the console</span>
  lengthCI</code></pre></div>
<pre><code>## [1] 61.80887 68.92360</code></pre>
<p><br></p>
<p>Here, we can see that our 95% CI excludes zero, so we can say that length has a significant effect on mass in this species. If we wanted to show this relationship in a graph, we now have to do the math by hand, which is why I forced you to learn the math involved with this. Here is an example of how one might do this:</p>
<p><br></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Plot the raw data</span>
  <span class="kw">plot</span>(length, mass)

<span class="co"># Make a sequence of new lengths</span>
  lens =<span class="st"> </span><span class="kw">seq</span>(<span class="kw">min</span>(length), <span class="kw">max</span>(length), <span class="dt">by=</span>.<span class="dv">1</span>)
  
<span class="co"># Predict new values for mass from lens using model</span>
<span class="co"># coefficients from the previous code chunk</span>
  masses =<span class="st"> </span>coefs[<span class="dv">1</span>,<span class="dv">1</span>] <span class="op">+</span><span class="st"> </span>coefs[<span class="dv">2</span>,<span class="dv">1</span>]<span class="op">*</span>lens
  
<span class="co"># Add lines to the plot</span>
  <span class="kw">lines</span>(lens, masses, <span class="dt">lty=</span><span class="dv">1</span>, <span class="dt">lwd=</span><span class="dv">2</span>, <span class="dt">col=</span><span class="st">&#39;blue&#39;</span>)</code></pre></div>
<p><img src="10_lmm_files/figure-html/unnamed-chunk-5-1.png" width="672" /></p>
<p><br></p>
<p>This gives us the overall estimate for the relationship between length and mass. What it does not get us are individual estimates of the intercepts like we might want. We can, however, get these out if we use the <code>coef</code> function:</p>
<p><br></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Get random intercepts and fixed sloppes</span>
  effs =<span class="st"> </span><span class="kw">coef</span>(lme.fit1)

<span class="co"># Have a look at the first few</span>
  <span class="kw">head</span>(effs<span class="op">$</span>pop)</code></pre></div>
<pre><code>##   (Intercept)   length
## 1    210.5218 65.36624
## 2    177.2758 65.36624
## 3    229.6049 65.36624
## 4    223.1122 65.36624
## 5    248.1194 65.36624
## 6    253.0195 65.36624</code></pre>
<p><br></p>
<p>This gives us the random intercept for each population so we can make predictions about them individually if we want to! It only gives us one value for the length parameter because we specified this as a main effect. If want to plot the results for population 3, for example, our code would look like this:</p>
<p><br></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Plot the raw data</span>
  <span class="kw">plot</span>(length[pop<span class="op">==</span><span class="dv">3</span>], mass[pop<span class="op">==</span><span class="dv">3</span>],
       <span class="dt">ylim =</span> <span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">500</span>), <span class="dt">pch=</span><span class="dv">21</span>, <span class="dt">bg=</span><span class="st">&#39;gray87&#39;</span>,
       <span class="dt">cex=</span><span class="fl">1.5</span>, <span class="dt">xlab=</span><span class="st">&#39;log(Length)&#39;</span>, <span class="dt">ylab=</span><span class="st">&#39;Mass&#39;</span>
       )
<span class="co"># Make a sequence of new lengths</span>
  lens =<span class="st"> </span><span class="kw">seq</span>(<span class="kw">min</span>(length), <span class="kw">max</span>(length), <span class="dt">by=</span>.<span class="dv">5</span>)
<span class="co"># Predict new values for mass from lens</span>
  masses =<span class="st"> </span>effs<span class="op">$</span>pop[<span class="dv">3</span>,<span class="dv">1</span>] <span class="op">+</span><span class="st"> </span>effs<span class="op">$</span>pop[<span class="dv">3</span>,<span class="dv">2</span>]<span class="op">*</span>lens
<span class="co"># Add lines to the plot</span>
  <span class="kw">lines</span>(lens, masses, <span class="dt">lty=</span><span class="dv">1</span>, <span class="dt">lwd=</span><span class="dv">2</span>, <span class="dt">col=</span><span class="st">&#39;blue&#39;</span>)</code></pre></div>
<p><img src="10_lmm_files/figure-html/unnamed-chunk-7-1.png" width="672" /></p>
<p><br></p>
<p>But, we still don’t really have a great way of looking at differences between groups if we are interested in those. Why is this? We do not have the technology. Basically, computing group-specific variances is too far ahead of our programming algorithms. But, we can use some simulation methods to do this.</p>
<p>The follwoing method was released in December 2016 to meet the growing need for characterizing uncertainty in group-level predictions from mixed models. Let’s take a look at how to use some of these tools.</p>
<p><br></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(merTools)

<span class="co"># Tell r which population we are </span>
<span class="co"># working with. We will store as a variable</span>
<span class="co"># upfront so we can easily change populations</span>
<span class="co"># by re-defining the variable, which I will</span>
<span class="co"># call `i`. We will use population 3 to stay</span>
<span class="co"># consistent with the example above</span>
  i=<span class="dv">3</span>
  
<span class="co"># Make a sequence of new lengths</span>
  lens =<span class="st"> </span><span class="kw">seq</span>(<span class="kw">min</span>(length),
             <span class="kw">max</span>(length),
             <span class="dt">by=</span>.<span class="dv">1</span>)
  
<span class="co"># Make a df that contains lengths</span>
<span class="co"># and a label for population</span>
  newd =<span class="st"> </span><span class="kw">data.frame</span>(
    <span class="dt">pop =</span> <span class="kw">rep</span>(i, <span class="kw">length</span>(lens)),
    <span class="dt">length =</span> lens
  )

<span class="co"># Simulate predictions from the relationship</span>
<span class="co"># stored in the model fit using our new data</span>
  PI &lt;-<span class="st"> </span><span class="kw">predictInterval</span>(<span class="dt">merMod =</span> lme.fit1, <span class="dt">newdata =</span> newd, 
                        <span class="dt">level =</span> <span class="fl">0.95</span>, <span class="dt">n.sims =</span> <span class="dv">10000</span>,
                        <span class="dt">stat =</span> <span class="st">&quot;median&quot;</span>, <span class="dt">type=</span><span class="st">&quot;linear.prediction&quot;</span>,
                        <span class="dt">include.resid.var =</span> <span class="ot">TRUE</span>
                        )

<span class="co"># Plot the raw data for the population of interest, i</span>
  <span class="kw">plot</span>(length[pop<span class="op">==</span>i], mass[pop<span class="op">==</span>i],
       <span class="dt">ylim =</span> <span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">500</span>), <span class="dt">pch=</span><span class="dv">21</span>, <span class="dt">bg=</span><span class="st">&#39;gray87&#39;</span>,
       <span class="dt">cex=</span><span class="fl">1.9</span>, <span class="dt">xlab=</span><span class="st">&#39;log(Length)&#39;</span>, <span class="dt">ylab=</span><span class="st">&#39;Mass&#39;</span>
       )

<span class="co"># Predict new values for mass from lens</span>
  masses =<span class="st"> </span>effs<span class="op">$</span>pop[i,<span class="dv">1</span>] <span class="op">+</span><span class="st"> </span>effs<span class="op">$</span>pop[i,<span class="dv">2</span>]<span class="op">*</span>lens
<span class="co"># Add lines to the plot</span>
  <span class="kw">lines</span>(newd<span class="op">$</span>length, PI<span class="op">$</span>fit, <span class="dt">lty=</span><span class="dv">1</span>, <span class="dt">lwd=</span><span class="dv">2</span>, <span class="dt">col=</span><span class="st">&#39;blue&#39;</span>) <span class="co"># Mean</span>
  <span class="kw">lines</span>(newd<span class="op">$</span>length, PI<span class="op">$</span>upr, <span class="dt">lty=</span><span class="dv">1</span>, <span class="dt">lwd=</span><span class="dv">2</span>, <span class="dt">col=</span><span class="st">&#39;red&#39;</span>)  <span class="co"># Upper CI</span>
  <span class="kw">lines</span>(newd<span class="op">$</span>length, PI<span class="op">$</span>lwr, <span class="dt">lty=</span><span class="dv">1</span>, <span class="dt">lwd=</span><span class="dv">2</span>, <span class="dt">col=</span><span class="st">&#39;red&#39;</span>)  <span class="co"># Lower CI</span></code></pre></div>
<p><img src="10_lmm_files/figure-html/unnamed-chunk-8-1.png" width="672" /></p>
<p><br></p>
<p>We could go through and do this for each population (56 total), and we would have a pretty nice (albeit slightly unwieldy) set of figures describing the relationship between length and mass. Alternatively, we could use the model coefficients to estimate the relationship across all populations, and to make predictions about unknown populations.</p>
<p><br></p>
</div>
<div id="bayesian-analysis-using-jags" class="section level4">
<h4>Bayesian analysis using JAGS</h4>
<p><br></p>
<p>Next, we will demonstrate how to implement the same model in JAGS. In principle, we are doing essentially the same thing here, but the approach is slightly more explicit.</p>
<blockquote>
<p>Write the model</p>
</blockquote>
<p>We start by specifying the model. The likelihood for the model is unchanged relative to what we would write for the fixed effects models with which we have worked previously. The only thing that changes is that instead of specifying priors on <span class="math inline">\(\alpha\)</span> for each population using <code>dnorm(0, 0.001)</code>, we specify each prior to using a mean of <code>mu.int</code> and a precision of <code>tau.int</code>. Here, <code>mu.int</code> and <code>tau.int</code> are <em>hyperparameters</em>, meaning that they govern the distribution from which our population-level parameters are drawn. Therefore, we need to specify <em>hyperpriors</em> for each of these parameters that can be used to estimate an overall (grand) mean effect. In the example below, we specify these using <code>dnorm(0, 0.001)</code> for <code>mu.int</code> and <code>dunif(0, 100)</code> for our variance (<code>sigma.int</code>).</p>
<p><br></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Write model</span>
modelstring=<span class="st">&quot;</span>
<span class="st">model {</span>

<span class="st"># Likelihood</span>
<span class="st"> for (i in 1:n) {</span>
<span class="st">    mass[i] ~ dnorm(mu[i], tau)                # The random variable</span>
<span class="st">    mu[i] &lt;- alpha[pop[i]] + beta* length[i] # Expectation</span>
<span class="st"> }</span>

<span class="st"># Priors</span>
<span class="st"> for (i in 1:ngroups){      </span>
<span class="st">    alpha[i] ~ dnorm(mu.int, tau.int)   # Random intercepts</span>
<span class="st"> }</span>

<span class="st"> mu.int ~ dnorm(0, 0.001)       # Mean hyperparameter for random intercepts</span>
<span class="st"> tau.int &lt;- 1 / (sigma.int * sigma.int)</span>
<span class="st"> sigma.int ~ dunif(0, 100)      # SD hyperparameter for random intercepts</span>

<span class="st"> beta ~ dnorm(0, 0.001)             # Common slope</span>
<span class="st"> tau &lt;- 1 / ( sigma * sigma)        # Residual precision</span>
<span class="st"> sigma ~ dunif(0, 100)              # Residual standard deviation</span>


<span class="st">}</span>
<span class="st">&quot;</span>
<span class="kw">writeLines</span>(modelstring, <span class="st">&quot;aspModel.txt&quot;</span>)</code></pre></div>
<blockquote>
<p>Package the data for jags</p>
</blockquote>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Bundle data</span>
  asp.data &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">mass =</span> <span class="kw">as.numeric</span>(mass), <span class="dt">pop =</span> <span class="kw">as.numeric</span>(pop), 
  <span class="dt">length =</span> length, <span class="dt">ngroups =</span> <span class="kw">max</span>(<span class="kw">as.numeric</span>(pop)), <span class="dt">n =</span> n)</code></pre></div>
<blockquote>
<p>Provide initial values for stochastic nodes</p>
</blockquote>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Inits function</span>
inits &lt;-<span class="st"> </span><span class="cf">function</span>(){<span class="kw">list</span>(<span class="dt">alpha =</span> <span class="kw">rnorm</span>(n.groups, <span class="dv">0</span>, <span class="dv">2</span>), <span class="dt">beta =</span> <span class="kw">rnorm</span>(<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>), 
<span class="dt">mu.int =</span> <span class="kw">rnorm</span>(<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>), <span class="dt">sigma.int =</span> <span class="kw">rlnorm</span>(<span class="dv">1</span>), <span class="dt">sigma =</span> <span class="kw">rlnorm</span>(<span class="dv">1</span>))}</code></pre></div>
<blockquote>
<p>Tell JAGS which parameters we want to trace</p>
</blockquote>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Parameters to estimate</span>
parameters &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;alpha&quot;</span>, <span class="st">&quot;beta&quot;</span>, <span class="st">&quot;mu.int&quot;</span>, <span class="st">&quot;sigma.int&quot;</span>, <span class="st">&quot;sigma&quot;</span>)</code></pre></div>
<blockquote>
<p>MCMC settings</p>
</blockquote>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># MCMC settings</span>
ni &lt;-<span class="st"> </span><span class="dv">2000</span>
nb &lt;-<span class="st"> </span><span class="dv">500</span>
nt &lt;-<span class="st"> </span><span class="dv">2</span>
nc &lt;-<span class="st"> </span><span class="dv">3</span></code></pre></div>
<blockquote>
<p>Run the model in JAGS</p>
</blockquote>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(R2jags)

<span class="co"># Start Gibbs sampling</span>
  out &lt;-<span class="kw">jags</span>(asp.data, inits, parameters, <span class="st">&quot;aspModel.txt&quot;</span>, <span class="dt">n.thin=</span>nt, 
  <span class="dt">n.chains=</span>nc, <span class="dt">n.burnin=</span>nb, <span class="dt">n.iter=</span>ni)</code></pre></div>
<blockquote>
<p>Now have a look at the results</p>
</blockquote>
<p>First, we can take a look at the model coefficients and diagnostics. Here, I am just going to print the model results for mean, sd, 95% CRI, and N<sub>eff</sub>.</p>
<p><br></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Get parameter estimates all by themselves</span>
  res =<span class="st"> </span>out<span class="op">$</span>BUGSoutput<span class="op">$</span>summary[, <span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>)]

<span class="co"># Inspect results</span>
  <span class="kw">print</span>(res, <span class="dt">digits =</span> <span class="dv">2</span>)</code></pre></div>
<pre><code>##             mean     sd    2.5%   97.5%  Rhat n.eff
## alpha[1] 209.864 10.890 188.690 230.465 1.001  2200
## alpha[2] 176.130 11.709 153.623 198.441 1.001  1800
## alpha[3] 229.300 11.392 206.976 250.813 1.001  2200
## alpha[4] 222.589 11.403 200.271 244.471 1.003   720
## alpha[5] 247.479 11.293 225.576 269.589 1.002  1500
## alpha[6] 252.767 11.384 230.278 275.813 1.001  1800</code></pre>
<pre><code>## 
##  . 
##  . 
##  . 
## </code></pre>
<pre><code>##               mean     sd     2.5%    97.5%  Rhat n.eff
## alpha[56]  219.195 10.959  198.536  240.781 1.001  2200
## beta        65.149  1.775   61.683   68.726 1.001  1900
## deviance  5749.462 11.689 5729.176 5774.631 1.001  2100
## mu.int     222.846  3.464  216.020  229.510 1.002  1600
## sigma       41.096  1.313   38.633   43.720 1.002  2000
## sigma.int   22.669  2.999   17.335   29.028 1.003   830</code></pre>
<p><br></p>
<p>Judging by our diagnostics, it looks like our estimates have converged nicely, and we see that we have sufficiently sampled posteriors for all 60(!) parameters of interest.</p>
<p>Finally, we can look at the results for the linear predictions. This week, we’ll take a look at how to present results for linear predictors. We will use the same example as we did for the model we fit in <code>lme4</code>.</p>
<blockquote>
<p>Make posterior predictions about length-weight relationship</p>
</blockquote>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Tell r which population we are working with. We will store as a variable</span>
<span class="co"># upfront so we can easily change populations by re-defining the variable, </span>
<span class="co"># which I will call `i`. We will use population 3 to stay consistent with</span>
<span class="co"># the example above</span>
  i=<span class="dv">3</span>
  
<span class="co"># Make a sequence of new lengths</span>
  lens =<span class="st"> </span><span class="kw">seq</span>(<span class="kw">min</span>(length), <span class="kw">max</span>(length), <span class="dt">by=</span>.<span class="dv">1</span>)
  
<span class="co"># Extract posteriors that we want to work with (parameters for the pop i)</span>
  alpha =<span class="st"> </span>out<span class="op">$</span>BUGSoutput<span class="op">$</span>sims.list<span class="op">$</span>alpha[,i]
  beta =<span class="st"> </span>out<span class="op">$</span>BUGSoutput<span class="op">$</span>sims.list<span class="op">$</span>beta  
  
<span class="co"># Predict mass as a function of population and length</span>
  <span class="co"># Make a blank matrix to hold the predictions</span>
  preds =<span class="st"> </span><span class="kw">matrix</span>(<span class="dt">data =</span> <span class="ot">NA</span>, <span class="dt">nrow=</span><span class="kw">length</span>(alpha), <span class="dt">ncol=</span><span class="kw">length</span>(lens))
  <span class="co"># Now make predictions for each new value of length from each of the</span>
  <span class="co"># MCMC samples of alpha and beta.</span>
  <span class="cf">for</span>(j <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(alpha)){
    <span class="cf">for</span>(t <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(lens)){
      preds[j, t] =<span class="st"> </span>alpha[j] <span class="op">+</span><span class="st"> </span>beta[j] <span class="op">*</span><span class="st"> </span>lens[t]
    }
  }

<span class="co"># Plot the raw data for the population of interest, i</span>
  <span class="kw">plot</span>(length[pop<span class="op">==</span>i], mass[pop<span class="op">==</span>i], <span class="dt">ylim =</span> <span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">500</span>), <span class="dt">pch=</span><span class="dv">21</span>, <span class="dt">bg=</span><span class="st">&#39;black&#39;</span>,
       <span class="dt">cex=</span><span class="fl">1.9</span>, <span class="dt">xlab=</span><span class="st">&#39;log(Length)&#39;</span>, <span class="dt">ylab=</span><span class="st">&#39;Mass&#39;</span>)

<span class="co"># Plot the posterior predictions</span>
  <span class="cf">for</span>(j <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(alpha)){
    <span class="kw">lines</span>(<span class="dt">x =</span> lens, <span class="dt">y =</span> preds[j, ], <span class="dt">col=</span><span class="kw">rgb</span>(.<span class="dv">7</span>,.<span class="dv">7</span>,.<span class="dv">7</span>,.<span class="dv">02</span>), <span class="dt">lwd=</span><span class="dv">1</span>)
  }
<span class="co"># Calculate the mean and 95% CRIs for posterior predictions</span>
  muPred =<span class="st"> </span><span class="kw">apply</span>(preds, <span class="dv">2</span>, mean)
  lowPred =<span class="st"> </span><span class="kw">apply</span>(preds, <span class="dv">2</span>, quantile, <span class="dt">probs=</span><span class="fl">0.025</span>)
  upPred =<span class="st"> </span><span class="kw">apply</span>(preds, <span class="dv">2</span>, quantile, <span class="dt">probs=</span><span class="fl">0.975</span>)
<span class="co"># Plot the mean and 95% CRI for predicted probability</span>
  <span class="kw">lines</span>(lens, muPred, <span class="dt">col=</span><span class="st">&#39;blue&#39;</span>, <span class="dt">lwd=</span><span class="dv">2</span>, <span class="dt">lty=</span><span class="dv">1</span>)
  <span class="kw">lines</span>(lens, upPred, <span class="dt">col=</span><span class="st">&#39;red&#39;</span>, <span class="dt">lwd=</span><span class="dv">2</span>, <span class="dt">lty=</span><span class="dv">2</span>)
  <span class="kw">lines</span>(lens, lowPred, <span class="dt">col=</span><span class="st">&#39;red&#39;</span>, <span class="dt">lwd=</span><span class="dv">2</span>, <span class="dt">lty=</span><span class="dv">2</span>)</code></pre></div>
<p><img src="10_lmm_files/figure-html/unnamed-chunk-17-1.png" width="672" /></p>
<p><br></p>
<p>As you can see, the mean prediction here is pretty much spot on with the REML approach to fitting the model. The big difference is that the precision is much tighter around the mean prediction for the Bayesian model. This is not because we did not specify the model correctly, or because we represented the uncertainty incorrectly. This is a phenomenon known as <strong>shrinkage</strong>, and it is a direct result of how the hierarchical modeling approach works in Bayesian inference. The reason for this shrinkage is that we are sharing information across populations in the Bayesian mode of inference based on how we specify our priors and how those feed into the likelihood.</p>
<p>What we have done with the intercept here is readily extended to include random effects on the estimates of beta. This will be one focus of our work in lab this week.</p>
<p>Of course, the methods covered this week are just for variables that assume normality. As you might expect by now, this framework is easily extended in both REML and Bayesian approaches to include a wide variety of error distributions. This will be the focus of our study next week, when we discussion generalized linear mixed models (GLMM).</p>
<p><br></p>
<p><br></p>
</div>
</div>
</div>
</div>

<!DOCTYPE html>
<p>Copyright &copy; 2017 Dan Stich. All rights reserved.</p>



</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
